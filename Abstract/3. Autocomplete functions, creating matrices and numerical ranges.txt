- СПОСОБЫ ЗАПОЛНЕНИЯ МАССИВА
    >>>np.array([0] * 10)
    array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])

    >>>np.array([1] * 15 )
    array([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])


    >>>np.array([i for i in range(10)])
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])


- БЫСТРЫЕ ФУНКЦИИ ДЛЯ СОЗДАНИЯ НЕОБХОДИМЫХ МАССИВОВ:
    1. >>>np.empty(10)
       10 произвольных чисел
       >>>np.empty(10, dtype='int16') # если добавить тип данных, получаем произвольные числа заданного типа
       array([ 92,   0,  69,   0, 108,   0, 108,   0, 111,   0], dtype=int16)
       >>>np.empty([1, 2, 3], dtype='int16')
       array([[[1, 0, 2],
                [0, 3, 0]]], dtype=int16)

    2. np.eye(4) # создает матрицу в которой по диагонали будет 1
       array([[1., 0., 0., 0.],
              [0., 1., 0., 0.],
              [0., 0., 1., 0.],
              [0., 0., 0., 1.]])

    3. np.identity(10, 'int16') # создаёт квадратную матрицу с 1 по диагонали, можно указывать тип данных
       array(
       [[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]], dtype=int16)

    4. np.zeros((3, 4, 5)) создает 1, 2, 3 мерные массивы полные 0
       array(
       [[[0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]],

       [[0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]],

       [[0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.],
        [0., 0., 0., 0., 0.]]])

    5. np.ones([3, 4, 5]) создает матрицу с единицами, также можно указать тип данных
    array(
       [[[1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.]],
       [[1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.]],
       [[1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.],
        [1., 1., 1., 1., 1.]]])


    6. np.full([2, 3, 4], '%') создает матрицу с указанными данными вторым аргументом
       array(
       [[['%', '%', '%', '%'],
        ['%', '%', '%', '%'],
        ['%', '%', '%', '%']],
       [['%', '%', '%', '%'],
        ['%', '%', '%', '%'],
        ['%', '%', '%', '%']]], dtype='<U1')

- ПОЛЕЗНЫЕ ФУНКЦИИ:

    1. np.mat('1, 2, 3, 4, 5')  позволяет строку преобразовать в матрицу
       matrix([[1, 2, 3, 4, 5]])
        - создание двумерной матрицы
            >>>np.mat('1, 2, 3; 4, 5, 6')
            matrix([[1, 2, 3],
                    [4, 5, 6]])
        - также работает со списком
        >>>np.mat([(1,2,3), (4,5,6)])
        matrix([[1, 2, 3],
        [4, 5, 6]])

    2.
       1. np.diag([1, 2, 3]) создаёт матрицу помещая по диагонали переданные агрументы
       array(
       [[1, 0, 0],
       [0, 2, 0],
       [0, 0, 3]])

       2. np.diag([(1, 2, 3), (10, 20, 30), (50, 500, 5000)])
       array([   1,   20, 5000]) вернёт данные по диагонали

    3. np.diagflat([(1, 2, 3), (10, 100, 1000), (20, 200, 2000)])
       array(
       [[   1,    0,    0,    0,    0,    0,    0,    0,    0],
       [   0,    2,    0,    0,    0,    0,    0,    0,    0],
       [   0,    0,    3,    0,    0,    0,    0,    0,    0],
       [   0,    0,    0,   10,    0,    0,    0,    0,    0],
       [   0,    0,    0,    0,  100,    0,    0,    0,    0],
       [   0,    0,    0,    0,    0, 1000,    0,    0,    0],
       [   0,    0,    0,    0,    0,    0,   20,    0,    0],
       [   0,    0,    0,    0,    0,    0,    0,  200,    0],
       [   0,    0,    0,    0,    0,    0,    0,    0, 2000]])

    4.
      1. np.tri(4, 5) создаёт трёхугольную матрицу
       array(
      [[1., 0., 0., 0., 0.],
       [1., 1., 0., 0., 0.],
       [1., 1., 1., 0., 0.],
       [1., 1., 1., 1., 0.]])

       2. a = np.array([(1, 2, 3), (4, 5, 6), (7, 8, 9)])
        array(
        >>>a
        [[1, 2, 3],
         [4, 5, 6],
         [7, 8, 9]])

        >>>np.tril(a)
        array(
        [[1, 0, 0],
         [4, 5, 0],
         [7, 8, 9]])

        3. a = np.array([1, 2, 3])
           >>>a
           array([1, 2, 3])
           np.tril(a)
           array(
           [[1, 0, 0],
            [1, 2, 0],
            [1, 2, 3]])

    5. a = np.array([1, 2, 3])
       np.vander(a)
       array(
      [[1, 1, 1],
       [4, 2, 1],
       [9, 3, 1]]

- ФУНКЦИИ ФОРМИРОВАНИЯ ЧИСЛОВЫХ ДИАПАЗОНОВ

    1. np.arange(5) принцип работы range(от до шаг)
       array([0, 1, 2, 3, 4])

       np.arange(1, 9, 0.5)
       array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5, 5. , 5.5, 6. , 6.5, 7. ,
       7.5, 8. , 8.5])

    2. np.linspace(0, np.pi, 0) деление Pi, старт/стоп/равномерное деление
       array([], dtype=float64)

       np.linspace(0, np.pi, 3)
       array([0.        , 1.57079633, 3.14159265])

       np.linspace(0, np.pi, 4)
       array([0.        , 1.04719755, 2.0943951 , 3.14159265])

    3. np.logspace(0, 1, 3) логарифмы
       array([ 1.        ,  3.16227766, 10.        ])

    4. np.geomspace(1, 4, 3) геометрическая прогрессия
       array([1., 2., 4.])

- ФУНКЦИИ ФОРМИРОВАНИЯ МАССИВОВ НА ОСНОВЕ ИМЕЮЩИХСЯ ДАННЫХ

    1. a = np.array([(1, 2), (8, 10)])
       b = np.copy(a)
       >>>b
       array(
       [[ 1,  2],
        [ 8, 10]])

    2. fromfunction

        . . .

    3. np.fromiter('hello', dtype='U1') формирует массив на основе строки
       array(['h', 'e', 'l', 'l', 'o'], dtype='<U1')

    4. np.fromstring('1 2 3', dtype='int16', sep=' ') производит массив из строки по указанному символу
       array([1, 2, 3], dtype=int16)

       np.fromstring('1, 2, 3', dtype='int16', sep=',')
       array([1, 2, 3], dtype=int16)